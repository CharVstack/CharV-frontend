{"version":3,"file":"index-6ed2bdb3.js","sources":["../../node_modules/jotai/esm/vanilla.mjs","../../node_modules/jotai/esm/index.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    depSet.forEach((a) => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */ new Set();\n    let isSync = true;\n    const getter = (a) => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          value.then(\n            (v) => {\n              promise.status = \"fulfilled\";\n              promise.value = v;\n              resolve(v);\n            },\n            (e) => {\n              promise.status = \"rejected\";\n              promise.reason = e;\n              reject(e);\n            }\n          ).finally(() => {\n            setAtomValue(atom, promise, depSet);\n          });\n          continuePromise = (next) => resolve(next);\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, (next) => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    flushPending();\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  const restoreAtoms = (values) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomValue(atom, value);\n        recomputeDependents(atom);\n      }\n    }\n    flushPending();\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      res: restoreAtoms,\n      dev_subscribe_state: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom,\n    res: restoreAtoms\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n","import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = (suspensePromise) => createSuspensePromise(\n  suspensePromise[SUSPENSE_PROMISE].b,\n  suspensePromise[SUSPENSE_PROMISE].o\n);\nconst promiseAbortMap = /* @__PURE__ */ new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        y: false\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise((resolve) => setTimeout(resolve)).then(\n                () => writeGetter(a, options)\n              );\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],"names":["keyCount","atom","read","write","key","config","get","set","arg","SUSPENSE_PROMISE","isSuspensePromise","__name","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","cancelSuspensePromise","_a","basePromise","cancelPromise","promiseAbortMap","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","newOriginalPromise","createSuspensePromise","suspensePromiseExtra","resolve","copySuspensePromise","hasInitialValue","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","committedAtomStateMap","mountedMap","pendingMap","stateListeners","mountedAtoms","value","atomState","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","cancelAllSuspensePromiseInCache","versionSet","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","setAtomState","prevAtomState","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","a","flushPending","setAtomReadError","error","setAtomSuspensePromise","setAtomPromiseOrValue","promiseOrValue","e","readAtomState","setAtomInvalidated","force","_","aState","r","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","s","setter","v","promiseOrVoid2","cancelledVersion","promiseOrVoid","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","setAtom","onUnmount","mountDependencies","committedAtomState","listener","pending","l","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","createScopeContainer","unstable_createStore","ScopeContextMap","getScopeContext","scope","createContext","atom$1","useAtomValue","ScopeContext","scopeContainer","useContext","store","versionFromProvider","getAtomValue","version2","valueFromReducer","atomFromReducer","rerenderIfChanged","useReducer","prev","nextVersion","nextValue","initialVersion","initialValue","useEffect","versionFromProvider2","unsubscribe","useDebugValue","useSetAtom","versionedWrite","useCallback","useAtom"],"mappings":"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"}